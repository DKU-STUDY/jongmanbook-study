<pre>
<h1>분할정복 요약정리</h1>
<h3>분할정복이 일반적인 재귀 호출과 다른점은 <b>문제를 한 조각과 나머지 전체로 나누는 대신 거의 같은 크기의 부분문제</b>로 나누는것이다.</h3>
<h3><b>세 가지의 구성 요소</b></h3>
<li> 문제를 더 작은 문제로 분할하는 과정 (divide) </li>
<li> 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정 (merge) </li>
<li> 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제 (base case) </li>

<h3><b>두가지 특성</b></h3>
<li>문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법이 있어야함</li>
<li>부분 문제의 답을 조합해 원래 문제의 답을 계산하는 효율적인 방법이 있어야함</li>

<h3><b>예제1: 수열의 빠른 합</b></h3>
fastSum() = 1 + 2 + ... + n 
= (1 + 2 + ... + n/2) + ((n/2 + 1)+ ... + n)

문제를 제귀적으로 풀기 위해서는 각 부분 문제를 '1부터 n 까지의 합' 꼴로 표현해야한다. 
첫 번째 부분 문제는 fastSum(n/2)로 나타낼수있지만, 두 번째 부분 문제는 그렇지 못하다.
두 번째 부분 문제는 다음과 같이 표현이 가능하다.
(n/2 + 1) + (n/2 + 2) + ... + (n/2 + n/2)
n/2 * n/2 + (1 + 2 + 3 + ... + n/2)
n/2 * n/2 + fastSum(n/2)

따라서 fastSum(n) = 2 * fastSum(n/2) + n^2/4 (n이 짝수일때) 이다.

int fastSum (int n){
    if(n==1) return 1;
    if(n%2) return fastSum(n-1) + n;
    return 2 * fastSum(n/2) + n^2/4
}

시간 복잡도
n을 이진수로 바꾸어서 계산해본다. O(lgn)

<h3><b>예제2: 행렬의 거듭제곱</b></h3>
n X n 크기의 행렬 A의 곱셈은 O(n^3)의 시간이 들게 된다.
A^m은 O(n^3m)번의 연산이 필요하다. 따라서 n = 100, m = 1,000,000이라고 하면 1초안에 계산 할 수없는 양이 된다.
분할 정복을 이용. A^m = A^(m/2) + A^(m/2) 으로 표현가능하다.

문제의 크기가 매번 절반에 가깝게 줄어들면 기저사례에 도달하기까지 걸리는 분할의 횟수가 줄어든다. 따라서 대부분의 분할 정복 알고리즘은 가능한 절반에 가깝게 문제를 나누고자 한다. 하지만 m이 홀수일때, A^m = A * A^(m-1) 의 방법이 아닌 절반에 가깝게 나누는 방법을 택한다면, 부분 문제의수가 늘어난다.
<img src="그림 7.2.png">
이 예시는 같은 문제라도 어떻게 분할하느냐에 따라 시간 복잡도 차이가 커진다는 것을 보여준다.

<h3><b>예제3: 병합 정렬과 퀵정렬</b></h3>
병합 정렬과 퀵 정렬은 모두 분할 정복 패러다임을 기반으로 해서 만들어졌다.
병합 정렬은 각 수열의 크기가 1이 될때까지 절반씩 쪼개 나간다. 나누는 과정은 단순히 나누는것이기 때문에 O(1)의 시간이 걸린다.
각각 나눠서 정렬한 배열을 하나의 배열로 합치는 병합 과정은 O(n)의 시간이 걸린다. 문제의 단계는 O(lgn)이 된다. 따라서 병합 정렬의 시간복잡도는 O(nlgn)이 된다.

퀵정렬은 pivot을 기준으로 작은 수를 왼쪽, 큰 수를 오른쪽으로 나누는 분할에 있어서 O(n)이 걸린다. 문제가 정렬되어있는 경우 문제가 나눠지지 않으므로 최악의 경우이다. 따라서 O(n^2)의 시간이 걸린다. 부분 문제가 절반에 가깝게 나누어진다면 O(nlgn)의 시간복잡도를 가진다.

<h3><b>예제4: 카라츠바의 빠른 곱셈 알고리즘</b></h3>
두개의 정수를 곱하는 일고리즘. 이때 정수는 수백자리, 수만 자리는 되는 큰 숫자이다.
<img src="그림 7.5.png">
위의 알고리즘은 자릿수 올림을 처리하는 함수 / 곱셈을 하는 함수 둘로 나누어서 처리한다.

카라츠바의 빠른 곱셈 알고리즘은 두 수를 각각 절반으로 쪼갠다.
a와 b가 각각 256자리 수라면 a1과 b1은 첫 128자리, a0와 b0는 그 다음 128자리를 저장한다.

a = a1 * 10^128 + a0
b = b1 * 10^128 + b0

a * b = (a1 * 10^128 + a0) * (b1 * 10^128 + b0)
= a1 * b1 * 10^256 + ( a1 * b0 + a0 * b1 ) * 10^128 + a0 * b0

a * b = (a1 * b1) * 10^256 + (a1 * b0 + a0 * b1) * 10^128 + a0 * b0
z2 = a1 * b1;
z0 = a0 * b0;
z1 = (a0 + a1) * (b0 + b1) - z0 - z2;

이방법은 곱셈을 세번밖에 쓰지 않는다. 
카라츠바 알고리즘의 구현은 단순한 O(n^2)보다 훨씩 복잡하기 때문에, 입력의 크기가 작으면 O(n^2) 알고리즘보다 느린 경우가 많다.
</pre>

